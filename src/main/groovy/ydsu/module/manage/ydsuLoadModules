#!/usr/bin/env groovy-shebang
package ydsu.module.manage

import groovy.transform.BaseScript
import org.yaml.snakeyaml.Yaml
import ydsu.module.manage.conf.PathConf
import ydsu.module.util.conf.AppDataDirConf
import ydsu.module.util.source.LocalModuleConf
import ydsu.module.util.source.LoggingBaseScript
import ydsu.module.util.source.ModuleConfFactory
import ydsu.module.util.source.PublicModuleConf

import static ydsu.module.util.source.Exec.longCommand

@BaseScript LoggingBaseScript baseScript

/**
 * Loads the changes from the `module.yml` file. Git clones modules into `~/appdata/ydsu/cache` and/or removes
 * the ones that are no longer present inside the `module.yml` file. Updates the ansible-managed block for ydsu's
 * system path inside `.bashrc`. Note that this command will not update existing modules, which can be done by the
 * `ydsuPull` command.
 */
@Grab(group = 'org.yaml', module = 'snakeyaml', version = '1.25', transitive = false)

void parseModulesConfiguration() {
    if (PathConf.MODULE_READ_CONF.exists()) {
        Yaml yaml = new Yaml()
        LinkedHashMap conf = yaml.load(PathConf.MODULE_READ_CONF.text)
        List<String> confLines = conf.module
        if (confLines) {
            info "Using module.yml: ${PathConf.MODULE_READ_CONF}"
            if (PathConf.MODULE_READ_CONF != PathConf.MODULE_WRITE_CONF) {
                info "To update the configuration create a copy of the above module.yml in ${PathConf.MODULE_WRITE_CONF}"
            }
            createModuleConfigurations(confLines)
        } else {
            warn "Modules list is empty, no modules are loaded: ${PathConf.MODULE_READ_CONF}"
        }
    } else {
        warn "File does not exist, no modules are loaded: ${PathConf.MODULE_READ_CONF}"
    }
}

void createModuleConfigurations(List<String> confLines) {
    ModuleConfFactory moduleConfFactory = new ModuleConfFactory()
    List<LocalModuleConf> moduleConfs
    try {
        moduleConfs = confLines.collect { moduleConfFactory.newModuleConf(it) }
    } catch (IllegalArgumentException e) {
        String msg = "Could not parse ${PathConf.MODULE_READ_CONF}: "
        if (PathConf.MODULE_READ_CONF == PathConf.MODULE_WRITE_CONF) {
            msg += "fix the errors and try again"
        } else {
            msg += "create a copy in ${PathConf.MODULE_WRITE_CONF}, fix the errors, and try again"
        }
        throw new RuntimeException(msg, e)
    }
    cloneModules(moduleConfs)
    generateSystemPathListString(moduleConfs)
    generateClassPathListString(moduleConfs)
    cleanCache(moduleConfs)
}

void cloneModules(List<LocalModuleConf> moduleConfs) {
    moduleConfs.each {
        if (it instanceof PublicModuleConf) {
            if (!it.moduleMetadata) {
                PublicModuleConf pmc = it
                pmc.gitClone()
            }
        }
    }
}

void generateSystemPathListString(List<LocalModuleConf> moduleConfs) {
    StringBuilder sb = new StringBuilder()
    String internalModulesParentDir = PathConf.MODULES_PARENT_DIR.replaceAll(AppDataDirConf.USER_HOME, '\\\$HOME')
    sb.append('        ').append(internalModulesParentDir).append('manage').append(':\\\n')
    sb.append('        ').append(internalModulesParentDir).append('util').append(':\\\n')
    TreeSet<String> allSystemPaths = moduleConfs.collect { it.systemPath }.flatten()
    if (allSystemPaths.isEmpty()) {
        warn "couldn't load any module"
    } else {
        allSystemPaths.each {
            sb.append('        ').append(it.replaceAll(AppDataDirConf.USER_HOME, '\\\$HOME')).append(':\\\n')
            // sb.append(it).append(':')
        }
    }
    sb.delete(sb.length() - 3, sb.length())
    // Pass the system path of the modules
    generateSystemPathPlaybook(sb.toString())
}

void generateSystemPathPlaybook(String systemPath) {
    def playbookYaml = """
---
- name: Configure system path for ydsu modules
  hosts: 127.0.0.1
  connection: local

  tasks:
  - name: Include ${PathConf.EXTEND_BASH_CONF} in ${PathConf.BASH_CONF}
    lineinfile:
      dest: ~/${PathConf.BASH_CONF}
      regexp: "{{ item.regexp }}"
      line: "{{ item.line }}"
      insertafter: EOF
      state: present
    with_items:
    - regexp: "^#?\\\\[\\\\[ -f ~/${PathConf.EXTEND_BASH_CONF} \\\\]\\\\]"
      line: '[[ -f ~/${PathConf.EXTEND_BASH_CONF} ]] && . ~/${PathConf.EXTEND_BASH_CONF}'
  - name: Insert/update system path configuration block in ${PathConf.EXTEND_BASH_CONF}
    blockinfile:
      path: ~/${PathConf.EXTEND_BASH_CONF}
      block: |
        PATH="\$PATH:\\
${systemPath}"
      marker: "${PathConf.SYSTEM_PATH_CONF_MARKER}"
      create: yes
  - name: Include ${PathConf.EXTEND_ZSH_CONF} in ${PathConf.ZSH_CONF}
    lineinfile:
      dest: ~/${PathConf.ZSH_CONF}
      regexp: "{{ item.regexp }}"
      line: "{{ item.line }}"
      insertafter: EOF
      state: present
      create: yes
    with_items:
    - regexp: "^#?\\\\[\\\\[ -f ~/${PathConf.EXTEND_ZSH_CONF} \\\\]\\\\]"
      line: '[[ -f ~/${PathConf.EXTEND_ZSH_CONF} ]] && . ~/${PathConf.EXTEND_ZSH_CONF}'
  - name: Insert/update system path configuration block in ${PathConf.EXTEND_ZSH_CONF}
    blockinfile:
      path: ~/${PathConf.EXTEND_ZSH_CONF}
      block: |
        PATH="\$PATH:\\
${systemPath}"
      marker: "${PathConf.SYSTEM_PATH_CONF_MARKER}"
      create: yes      
"""
    PathConf.SYSTEM_PATH_WRITE_PLAYBOOK.write(playbookYaml)
    runPlaybook()
}

void runPlaybook() {
    longCommand("ansible-playbook ${PathConf.SYSTEM_PATH_WRITE_PLAYBOOK}")
}

void generateClassPathListString(List<LocalModuleConf> moduleConfs) {
    StringBuilder sb = new StringBuilder()
    sb.append('List<String> classPathList = [')
    TreeSet<String> classPathList = moduleConfs.collect { it.classPath }.flatten()
    classPathList << PathConf.CLASS_PATH_ROOT
    new File(PathConf.CLASS_PATH_ROOT).eachDirRecurse {
        classPathList << it.toString()
    }
    if (!classPathList.isEmpty()) {
        classPathList.each {
            sb.append('"').append(it.replaceAll(AppDataDirConf.USER_HOME, '\\\${System.getProperty(\'user.home\')}')).append('",\n')
        }
    }
    sb.delete(sb.length() - 2, sb.length()).append('].collect { it.toString() }')
    generateGroovyConfigScriptWithClassPath(sb.toString())
}

void generateGroovyConfigScriptWithClassPath(String classPathListString) {
    String groovyCompilerConf = """
package ydsu.module.util.conf
/**
 * For documentation refer to
 *
 * - http://docs.groovy-lang.org/latest/html/api/org/codehaus/groovy/control/CompilerConfiguration.html
 * - https://mrhaki.blogspot.gr/2016/01/groovy-goodness-customising-groovy.html
 *
 * Starting from the src/main/groovy directory, add all the subdirectories recursively to the classpath
 * (src/main/groovy/ydsu/module/util/../../../).
 */
${classPathListString}

String ydsuClasspath = System.getenv("YDSU_CLASSPATH")
if (ydsuClasspath) {
    classPathList.addAll(ydsuClasspath.tokenize(':'))
}

configuration.setClasspathList(classPathList)
// configuration.setScriptBaseClass('ysdu.util.source.LoggingBaseScript')
"""
    saveGroovyConfigScript(groovyCompilerConf)
}

void saveGroovyConfigScript(String groovyCompilerConf) {
    PathConf.GROOVY_COMPILER_WRITE_CONF.write(groovyCompilerConf)
}

void cleanCache(List<LocalModuleConf> moduleConfs) {
    Set<String> owners = moduleConfs.collect { it.owner }
    Set<String> repositories = moduleConfs.collect { "${it.owner}/${it.repository}".toString() }
    File moduleSource = new File(PathConf.PUBLIC_MODULES_SOURCE_DIR)
    if (moduleSource.exists()) {
        moduleSource.eachDir {
            if (owners.contains(it.name)) {
                it.eachDir {
                    String repo = "${it.parentFile.name}/${it.name}"
                    if (!repositories.contains(repo)) {
                        if (it.deleteDir()) {
                            info "Repository '${repo}' is no longer in use inside ${PathConf.MODULE_READ_CONF}: " +
                                    "directory deleted: ${it.toString()}"
                        } else {
                            error "Repository '${repo}' is no longer in use inside ${PathConf.MODULE_READ_CONF}: " +
                                    "however directory could not be deleted: ${it.toString()}"
                        }
                    }
                }
            } else {
                if (it.deleteDir()) {
                    info "Repository owner '${it.name}' is no longer in use inside ${PathConf.MODULE_READ_CONF}: " +
                            "directory deleted: ${it.toString()}"
                } else {
                    error "Repository owner '${it.name}' is no longer in use inside ${PathConf.MODULE_READ_CONF}: " +
                            "however directory could not be deleted: ${it.toString()}"
                }
            }
        }
    }
}

parseModulesConfiguration()
